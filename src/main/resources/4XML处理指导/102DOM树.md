# DOM树

我们将使用此XML文档作为示例：





```
<书>
  <title>测试书</ title>
  <章节>
    <TITLE>通道1 </ TITLE>
    <第> P1.1 </对>
    <第> P1.2 </对>
    <第> P1.3 </对>
  </章节>
  <章节>
    <TITLE> Ch2的</ TITLE>
    <第> P2.1 </对>
    <第> P2.2 </对>
  </章节>
</书>
```

W3C DOM将XML文档建模为节点树。上述XML的节点树可以显示为：

```
文献
 |
 +  - 元素书
     |
     +  - 文字“\ n”
     |
     +  - 元素标题
     | |
     | +  - 文本“测试书”
     |
     +  - 文字“\ n”
     |
     +  - 元素章节
     | |
     | +  - 文字“\ n”
     | |
     | +  - 元素标题
     | | |
     | | +  - 文字“Ch1”
     | |
     | +  - 文字“\ n”
     | |
     | +  - 元素段
     | | |
     | | +  - 文字“p1.1”
     | |
     | +  - 文字“\ n”
     | |
     | +  - 元素段
     | | |
     | | +  - 文字“p1.2”
     | |
     | +  - 文字“\ n”
     | |
     | +  - 元素段
     | |
     | +  - 文字“p1.3”
     |
     +  - 元素
         |
         +  - 文字“\ n”
         |
         +  - 元素标题
         | |
         | +  - 文字“Ch2”
         |
         +  - 文字“\ n”
         |
         +  - 元素段
         | |
         | +  - 文字“p2.1”
         |
         +  - 文字“\ n”
         |
         +  - 元素段
             |
             +  - 文字“p2.2”
```

请注意，干扰`"\n  "`-s是换行符（此处用`\n`FTL字符串文字中使用的转义序列表示）和标记之间的缩进空格。

关于DOM相关术语的说明：

- 树的最顶层节点称为**根**。对于XML文档，它始终是“文档”节点，而不是最顶层的元素（`book`在此示例中）。
- 我们说节点B是节点A 的**子**节点，如果B是A的 *直接*后代。例如，两个`chapter`元素节点是元素节点的子`book`节点，但 `para`元素节点不是。
- 我们说节点A是节点B 的**父**节点，如果A是节点B的 *直接*上升节，也就是说，如果B是A的`book` 子节点。例如，元素节点是两个`chapter`元素节点的父节点，但它不是`para`元素节点的父 节点。
- XML文档中可能存在多种组件，例如元素，文本，注释，处理指令等。所有这些组件都是DOM树中的节点，因此存在元素节点，文本节点，注释节点等。原则上，元素的属性也是树中的节点 - 它们是元素的子节点 - 但是，通常我们（以及其他XML相关技术）将它们排除在元素子节点之外。所以基本上他们不算作儿童节点。

程序员将DOM树的文档节点放入FreeMarker数据模型中，然后模板作者可以使用该变量作为起始点来遍历DOM树。

FTL中的DOM节点对应于**节点变量**。这是一个变量类型，类似于字符串，数字，散列等。节点变量类型使FreeMarker可以获取父节点和节点的子节点。从技术上讲，这是允许模板作者在节点之间导航，比如使用[节点内置函数](https://freemarker.apache.org/docs/ref_builtins_node.html)或[`visit`](https://freemarker.apache.org/docs/ref_directive_visit.html#ref.directive.visit)和 [`recurse`](https://freemarker.apache.org/docs/ref_directive_visit.html#ref.directive.recurse) 指令; 我们将在后面的章节中展示这些用法。